## 一、static 关键字（可以用于修饰属性，也可以用于修饰方法，还可以用于修饰类）
### 1、static 修饰属性：

无论一个类生成了多少个对象，所有这些对象共同使用唯一 一份静态的成员变量；

一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也会随之发生变化。

如果一个成员变量是 static 的，那么我们可以通过类名.成员变量名的方式来使用它（推荐使用这种方式）。

非静态的成员变量在每个对象中是独立的（对象的非静态成员变量独立存在）

### 2、 static 修饰方法（static 修饰的方法叫做静态方法）

static方法其实就是没有this的方法

所以静态方法内不能调用非静态方法

对于静态方法来说，可以使用类名.方法名的方式来访问。

方法的重写与隐藏：静态方法只能继承，不能重写（Override）。

eg
M m = new N();
m.output();//该引用调用M类的output()静态方法
3、static修饰类：静态内部类
4、 static 代码块：静态代码块。
静态代码块的作用也是完成一些初始化工作。

首先执行静态代码块，然后执行构造方法。

静态代码块在类被加载的时候执行， 而构造方法是在生成对象的时候执行；

要想调用某个类来生成对象，首先需要将类加载到 Java 虚拟机上（JVM），然后由 JVM 加载这个类来生成对象。

类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所以静态代码块也只会被执行一次；

而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以 new 一次就会调用构造方法一次。

如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类 的静态代码块，一直执行到最底层类的静态代码块,

然后再去执行最顶层类的构造方法，一直执行到最底层类的构造方法。注意：静态代码块只会执行一次、再次new对象时只会执行构造方法。
5、在方法中访问成员变量
不能在静态方法中访问非静态成员变量

可以在静态方法中访问静态的成员变量

可以在非静态方法中访问静态的成员变量

总结：静态的只能访问静态的；非静态的可以访问一切。

6、不能在静态方法中使用 this 关键字。

this关键字表示对当前对象的引用，对于一个静态方法来说可以不生成对象，直接通过类来调用，

那么当前类便不知是谁，所以在静态方法中不能使用this关键字，this关键字可看做是一个非静态的成员变量。

## 二、final关键字（final 可以修饰属性、方法、类。 ）

1、final 修饰属性：当一个属性被 final 所修饰时，表示该属性不能被改写。

当 final 修饰一个原生数据类型时，表示该原生数据类型的值不能发生变化 （比如说不能从 10 变为 20）；

当 final 修饰一个引用类型时，表示该引用类型不能再指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。

2、final 修饰方法：当一个方法被 final 所修饰时，表示该方法是一个终态方法， 即不能被重写（Override）。

3、final 修饰类：当一个类被 final 所修饰时，表示该类是一个终态类，即不能被继承。

final类型成员变量赋初值

在声明 final 类型的成员变量时就赋上初值

在声明 final 类型的成员变量时不赋初值，但在类的所有构造方法中都为其赋 上初值。

效率原因。如果一个方法指定为final，就是同意编译器将针对该方法的所有调用都转为内嵌（inline）调用final和private

类中所有的private方法隐含是final，可以为private方法增加final修饰，但没有其他额外意义

## 三、this关键字

  引例：
  ```Java
  
      class MyClass{……}
       MyClass a = new MyClass();
         MyClass b = new MyClass();
         a.f(0);
         b.f(1);
    ···    
    
都调用f()，如何区分是a的还是b的？

编译器将“所操作对象的引用”作为第一个参数传递给调用函数

MyClass.f(a,0);

MyClass.f(b,1);

a，b参数是编译器“偷偷”传入的，无法在代码中使用。

实际上有个参数表示“所操作对象的引用”

如果想在f()内部使用“所操作对象的引用”怎么办？=>this
···Java
 class MyClass{
   private int number;
   private String text;
   MyClass(int number, String text){
        this.number = number;
        this.text = text;
   }
   MyClass(){
        this(0,"null");
   }
}
